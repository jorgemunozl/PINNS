String Comparison Algorithms: Descriptions and Pseudocode

This document provides a summary and pseudocode for common string comparison algorithms.

---

### 1. Levenshtein Distance

*   **Description**: Calculates the minimum number of single-character edits (insertions, deletions, or substitutions) required to change one string into another. It's ideal for spell checking and finding typos.
*   **Pseudocode**:

```
function LevenshteinDistance(string s1, string s2):
  // Ensure s1 is the longer string for optimization
  if length of s1 < length of s2:
    return LevenshteinDistance(s2, s1)

  // If s2 is empty, the cost is the length of s1 (all insertions)
  if length of s2 == 0:
    return length of s1

  // Initialize a list (previous_row) to hold the distances
  // This represents the cost of transforming an empty string to prefixes of s2
  previous_row = a list of numbers from 0 to length of s2

  // Loop through each character in s1
  for i from 0 to length of s1 - 1:
    c1 = s1[i]
    // Start the current_row with the deletion cost
    current_row = [i + 1]

    // Loop through each character in s2
    for j from 0 to length of s2 - 1:
      c2 = s2[j]
      
      // Calculate costs for each operation
      insertions = previous_row[j + 1] + 1
      deletions = current_row[j] + 1
      
      // Substitution cost is 0 if characters are the same, 1 otherwise
      substitution_cost = 0 if c1 == c2 else 1
      substitutions = previous_row[j] + substitution_cost
      
      // Append the minimum of the three costs to the current_row
      current_row.append(minimum(insertions, deletions, substitutions))
      
    // The current_row becomes the previous_row for the next iteration
    previous_row = current_row
    
  // The final distance is the last element in the last computed row
  return previous_row[length of s2]
```

---

### 2. Damerau-Levenshtein Distance

*   **Description**: An extension of Levenshtein that also considers the **transposition** of two adjacent characters as a single edit. This is very effective for human typing errors.
*   **Pseudocode**:
    *Note: This is more complex and requires a 2D matrix.*

```
function DamerauLevenshteinDistance(string s1, string s2):
  // Create a 2D matrix 'd' of size (len(s1)+1) x (len(s2)+1)
  let d be a 2D array of integers

  // Initialize the first row and column of the matrix
  for i from 0 to length of s1:
    d[i][0] = i
  for j from 0 to length of s2:
    d[0][j] = j

  // Loop through the matrix
  for i from 1 to length of s1:
    for j from 1 to length of s2:
      // Cost is 0 if characters are the same, 1 otherwise
      cost = 0 if s1[i-1] == s2[j-1] else 1
      
      // Calculate costs for insertion, deletion, and substitution
      d[i][j] = minimum(
        d[i-1][j] + 1,      // Deletion
        d[i][j-1] + 1,      // Insertion
        d[i-1][j-1] + cost  // Substitution
      )
      
      // Check for transposition
      if i > 1 and j > 1 and s1[i-1] == s2[j-2] and s1[i-2] == s2[j-1]:
        d[i][j] = minimum(d[i][j], d[i-2][j-2] + cost) // Transposition

  // Return the value in the bottom-right cell of the matrix
  return d[length of s1][length of s2]
```

---

### 3. Hamming Distance

*   **Description**: Only works for strings of the **same length**. It counts the number of positions at which the corresponding characters are different.
*   **Pseudocode**:

```
function HammingDistance(string s1, string s2):
  // Ensure strings are of equal length
  if length of s1 != length of s2:
    throw new Error("Strings must be of the same length")

  distance = 0
  // Loop through the strings and compare characters at each position
  for i from 0 to length of s1 - 1:
    if s1[i] != s2[i]:
      distance = distance + 1
      
  return distance
```

---

### 4. Jaro-Winkler Distance

*   **Description**: Measures similarity based on matching characters and transpositions. It's best for short strings like names and gives a bonus to strings that match from the beginning. The result is a score from 0 (no similarity) to 1 (exact match).
*   **Pseudocode**:

```
function JaroWinklerDistance(string s1, string s2):
  // 1. Calculate Jaro Distance
  // Define match window size
  match_distance = floor(max(len(s1), len(s2)) / 2) - 1

  // Find matching characters
  let s1_matches be a boolean array of size len(s1), initialized to false
  let s2_matches be a boolean array of size len(s2), initialized to false
  matching_chars = 0
  for i from 0 to len(s1) - 1:
    start = max(0, i - match_distance)
    end = min(i + match_distance + 1, len(s2))
    for j from start to end - 1:
      if s2_matches[j] is false and s1[i] == s2[j]:
        s1_matches[i] = true
        s2_matches[j] = true
        matching_chars = matching_chars + 1
        break

  if matching_chars == 0:
    return 0.0

  // Count transpositions
  transpositions = 0
  k = 0
  for i from 0 to len(s1) - 1:
    if s1_matches[i] is true:
      while s2_matches[k] is false:
        k = k + 1
      if s1[i] != s2[k]:
        transpositions = transpositions + 1
      k = k + 1
  
  transpositions = floor(transpositions / 2)

  // Calculate Jaro similarity
  jaro_sim = (matching_chars / len(s1) + 
              matching_chars / len(s2) + 
             (matching_chars - transpositions) / matching_chars) / 3

  // 2. Calculate Winkler Bonus
  prefix_len = 0
  // Find length of common prefix (up to 4 characters)
  for i from 0 to min(len(s1), len(s2)) - 1:
    if s1[i] == s2[i]:
      prefix_len = prefix_len + 1
    else:
      break
  
  prefix_len = min(4, prefix_len)
  
  // Calculate final Jaro-Winkler distance
  winkler_sim = jaro_sim + (prefix_len * 0.1 * (1 - jaro_sim))
  
  return winkler_sim
```

---

### 5. Jaccard Similarity

*   **Description**: Treats strings as sets of n-grams (substrings of length n). It measures similarity as the size of the intersection of the sets divided by the size of their union.
*   **Pseudocode**:

```
function JaccardSimilarity(string s1, string s2, integer n=2):
  // Create sets of n-grams for each string
  set1 = create_ngrams(s1, n)
  set2 = create_ngrams(s2, n)
  
  // Calculate the intersection of the two sets
  intersection = set1.intersection(set2)
  
  // Calculate the union of the two sets
  union = set1.union(set2)
  
  // Jaccard Similarity is |Intersection| / |Union|
  if size of union == 0:
    return 1.0 // Both strings are empty
  else:
    return (size of intersection) / (size of union)

function create_ngrams(string text, integer n):
  // Helper function to generate n-grams
  let ngrams be a set of strings
  for i from 0 to length of text - n:
    ngrams.add(substring of text from i to i+n)
  return ngrams
```

---
